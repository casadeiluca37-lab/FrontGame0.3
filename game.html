<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FrontGame - Battle Royale</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            /* Rimuove il cursore per lasciare solo il mirino */
            cursor: none; 
        }

        /* HUD Overlay */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            color: white;
            font-weight: bold;
        }

        /* Health Bar */
        #healthBar {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 300px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
        }

        #healthBar .label {
            font-size: 14px;
            margin-bottom: 5px;
            color: #2ECC71;
        }

        #healthBar .bar {
            width: 100%;
            height: 25px;
            background: #2C3E50;
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid #34495E;
        }

        #healthBar .fill {
            height: 100%;
            background: linear-gradient(90deg, #2ECC71, #27AE60);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* Weapon Info */
        #weaponInfo {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            min-width: 200px;
        }

        #weaponInfo .weapon-name {
            font-size: 18px;
            color: #3498DB;
            margin-bottom: 8px;
        }

        #weaponInfo .ammo {
            font-size: 24px;
            color: #F39C12;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            /* Mirino di Fortnite: 4 linee che si espandono (qui solo un + fisso) */
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Interaction Prompt */
        #interactionPrompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin-top: 50px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            display: none;
            color: #F39C12;
            pointer-events: none;
        }

        /* Kill Feed */
        #killFeed {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
        }

        .kill-message {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 5px;
            font-size: 14px;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Damage Indicator */
        .damage-indicator {
            position: fixed;
            font-size: 32px;
            font-weight: bold;
            color: #E74C3C;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
            z-index: 200;
        }

        @keyframes damageFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px) scale(1.5);
            }
        }

        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
        }

        #startScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
        }

        #startScreen .controls {
            background: rgba(0, 0, 0, 0.3);
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            max-width: 600px;
        }

        #startScreen .controls h2 {
            margin-bottom: 15px;
            color: #F39C12;
        }

        #startScreen .controls p {
            margin: 8px 0;
            font-size: 16px;
        }

        #startButton {
            padding: 15px 40px;
            font-size: 24px;
            background: #2ECC71;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            pointer-events: auto;
        }

        #startButton:hover {
            background: #27AE60;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>ðŸŽ® FRONTGAME: BATTLE ROYALE PROTOTYPE</h1>
        <div class="controls">
            <h2>CONTROLLI</h2>
            <p><strong>WASD</strong> - Movimento</p>
            <p><strong>SPAZIO</strong> - Salto</p>
            <p><strong>SHIFT</strong> - Corsa</p>
            <p><strong>MOUSE</strong> - Mira</p>
            <p><strong>CLICK SINISTRO</strong> - Spara</p>
            <p><strong>E</strong> - Raccogli arma / Apri cassa</p>
            <p><strong>1-3</strong> - Cambia arma</p>
        </div>
        <button id="startButton">INIZIA PARTITA</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div id="healthBar">
            <div class="label">SALUTE</div>
            <div class="bar">
                <div class="fill" id="healthFill">100</div>
            </div>
        </div>

        <div id="weaponInfo">
            <div class="weapon-name" id="weaponName">Nessuna Arma</div>
            <div class="ammo" id="ammoCount">0 / 0</div>
        </div>

        <div id="crosshair"></div>
        <div id="interactionPrompt"></div>
        <div id="killFeed"></div>
    </div>

    <script>
        /**
         * ============================================
         * FRONTGAME: THIRD-PERSON SHOOTER GAME LOGIC
         * ============================================
         */

        // ==================== CONFIGURATION ====================
        const CONFIG = {
            player: {
                height: 1.8,
                speed: 5,
                sprintMultiplier: 1.5,
                jumpForce: 8,
                health: 100,
                maxHealth: 100,
                radius: 0.3
            },
            weapons: {
                pistol: {
                    name: 'Pistola',
                    damage: 15,
                    fireRate: 300,
                    ammo: 12,
                    maxAmmo: 12,
                    range: 50,
                    bulletSpeed: 100
                },
                rifle: {
                    name: 'Fucile d\'Assalto',
                    damage: 25,
                    fireRate: 150,
                    ammo: 30,
                    maxAmmo: 30,
                    range: 100,
                    bulletSpeed: 150
                },
                shotgun: {
                    name: 'Fucile a Pompa',
                    damage: 60, // Danno base per pellet
                    fireRate: 800,
                    ammo: 6,
                    maxAmmo: 6,
                    range: 20,
                    bulletSpeed: 80,
                    pellets: 8 // Colpi sparsi
                }
            },
            bot: {
                count: 5,
                speed: 4,
                detectionRange: 30,
                shootingRange: 40,
                health: 100,
                damage: 10,
                radius: 0.3
            },
            world: {
                size: 200,
                gravity: -20
            }
        };

        // ==================== GLOBAL VARIABLES & INITIALIZATION ====================
        let scene, camera, renderer, controls;
        let player, bots = [], bullets = [], interactables = [];
        let keys = {};
        let gameState = { isPlaying: false, kills: 0 };
        let clock = new THREE.Clock();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let audioManager = new AudioManager();
        let canvas = document.getElementById('gameCanvas');
        let floorMesh;

        // HUD Elements
        const healthFill = document.getElementById('healthFill');
        const weaponNameEl = document.getElementById('weaponName');
        const ammoCountEl = document.getElementById('ammoCount');
        const interactionPromptEl = document.getElementById('interactionPrompt');
        const killFeedEl = document.getElementById('killFeed');
        const startScreenEl = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');

        // ==================== CLASSES ====================

        // --- AUDIO MANAGER ---
        class AudioManager {
            constructor() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.masterVolume = 0.3;
            }

            playGunshot(weaponType = 'rifle') {
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);

                let freq, duration;

                if (weaponType === 'shotgun') {
                    freq = 80;
                    duration = 0.3;
                    gainNode.gain.setValueAtTime(this.masterVolume * 0.8, this.context.currentTime);
                } else if (weaponType === 'pistol') {
                    freq = 200;
                    duration = 0.1;
                    gainNode.gain.setValueAtTime(this.masterVolume * 0.5, this.context.currentTime);
                } else {
                    freq = 150;
                    duration = 0.15;
                    gainNode.gain.setValueAtTime(this.masterVolume * 0.6, this.context.currentTime);
                }

                oscillator.frequency.value = freq;
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + duration);
            }
            
            playChestOpen() {
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(400, this.context.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, this.context.currentTime + 0.2);
                gainNode.gain.setValueAtTime(this.masterVolume * 0.4, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + 0.3);
            }

            playHitSound() {
                if (this.context.state === 'suspended') {
                    this.context.resume();
                }
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = 100;
                gainNode.gain.setValueAtTime(this.masterVolume * 0.5, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + 0.2);
            }
        }

        // --- WEAPON CLASS ---
        class Weapon {
            constructor(type, position) {
                this.type = type;
                this.config = CONFIG.weapons[type];
                this.ammo = this.config.maxAmmo; // Start with full ammo
                this.lastFireTime = 0;
                this.position = position;
                this.mesh = this.createMesh();
                this.mesh.userData = { isWeapon: true, owner: null, weaponType: type };
            }

            createMesh() {
                const geometry = new THREE.BoxGeometry(0.5, 0.2, 1.5);
                let color = 0x888888;
                
                if (this.type === 'rifle') color = 0x4A90E2; // Blu
                if (this.type === 'shotgun') color = 0xE74C3C; // Rosso
                if (this.type === 'pistol') color = 0x95A5A6; // Grigio
                
                const material = new THREE.MeshPhongMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(this.position);
                mesh.position.y = 0.5;
                mesh.rotation.y = Math.PI / 2;
                
                return mesh;
            }

            canFire() {
                const now = Date.now();
                return this.ammo > 0 && (now - this.lastFireTime) >= this.config.fireRate;
            }

            fire(origin, direction, owner) {
                if (this.canFire()) {
                    this.ammo--;
                    this.lastFireTime = Date.now();
                    
                    if (this.type === 'shotgun') {
                        // Spari a pallettoni
                        for(let i = 0; i < this.config.pellets; i++) {
                            const spread = new THREE.Vector3(
                                (Math.random() - 0.5) * 0.5,
                                (Math.random() - 0.5) * 0.5,
                                0
                            );
                            const finalDirection = direction.clone().add(spread).normalize();
                            bullets.push(new Bullet(origin, finalDirection, this.config.damage, this.config.bulletSpeed, owner, this.type));
                        }
                    } else {
                        // Colpo singolo
                        bullets.push(new Bullet(origin, direction, this.config.damage, this.config.bulletSpeed, owner, this.type));
                    }
                    
                    return true;
                }
                return false;
            }

            reload() {
                this.ammo = this.config.maxAmmo;
            }
        }

        // --- BULLET CLASS ---
        class Bullet {
            constructor(position, direction, damage, speed, owner, weaponType) {
                this.position = position.clone();
                this.direction = direction.clone().normalize();
                this.damage = damage;
                this.speed = speed;
                this.owner = owner;
                this.lifetime = 2000;
                this.createdAt = Date.now();
                this.mesh = this.createMesh(weaponType);
                this.mesh.userData = { isBullet: true, owner: owner };
            }

            createMesh(weaponType) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                let color = 0xFFFF00;
                if (weaponType === 'shotgun') color = 0xFF8800;
                
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    emissive: color
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(this.position);
                
                return mesh;
            }

            update(deltaTime) {
                const movement = this.direction.clone().multiplyScalar(this.speed * deltaTime);
                this.position.add(movement);
                this.mesh.position.copy(this.position);
                
                return Date.now() - this.createdAt < this.lifetime;
            }
        }

        // --- PLAYER CLASS ---
        class Player {
            constructor(position) {
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                this.rotation = 0;
                this.health = CONFIG.player.health;
                this.maxHealth = CONFIG.player.maxHealth;
                this.isJumping = false;
                this.isSprinting = false;
                this.weapons = [];
                this.currentWeaponIndex = -1;
                this.mesh = this.createMesh();
                this.mesh.userData = { isPlayer: true, entity: this };
            }

            createMesh() {
                const group = new THREE.Group();
                
                // Body (Capsula come i bot ma colore diverso)
                const bodyGeometry = new THREE.CapsuleGeometry(0.3, 1.2, 4, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x3498DB }); // Blu
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.9;
                group.add(body);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshPhongMaterial({ color: 0xFFDBAC });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.6;
                group.add(head);
                
                group.position.copy(this.position);
                return group;
            }

            pickupWeapon(weapon) {
                if (this.weapons.length < 3) {
                    // Check if player already has this type of weapon
                    const existingWeaponIndex = this.weapons.findIndex(w => w.type === weapon.type);
                    
                    if (existingWeaponIndex !== -1) {
                        // Already has it, just refill ammo
                        this.weapons[existingWeaponIndex].ammo = this.weapons[existingWeaponIndex].config.maxAmmo;
                        this.switchWeapon(existingWeaponIndex);
                    } else {
                        // New weapon
                        this.weapons.push(weapon);
                        this.currentWeaponIndex = this.weapons.length - 1;
                    }

                    scene.remove(weapon.mesh);
                    interactables = interactables.filter(i => i.mesh !== weapon.mesh);
                    updateHUD();
                    return true;
                }
                return false;
            }

            getCurrentWeapon() {
                if (this.currentWeaponIndex >= 0 && this.currentWeaponIndex < this.weapons.length) {
                    return this.weapons[this.currentWeaponIndex];
                }
                return null;
            }

            switchWeapon(index) {
                if (index >= 0 && index < this.weapons.length) {
                    this.currentWeaponIndex = index;
                    updateHUD();
                }
            }

            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                updateHUD();
                if (this.health <= 0) {
                    console.log("Player eliminated!");
                    // To do: Game Over screen
                    return true;
                }
                return false;
            }

            update(deltaTime) {
                // Apply Gravity
                this.velocity.y += CONFIG.world.gravity * deltaTime;

                // Collision with floor (simple check)
                if (this.position.y + this.velocity.y * deltaTime <= 0) {
                    this.position.y = 0;
                    this.velocity.y = 0;
                    this.isJumping = false;
                }

                // Update Position
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Update Mesh
                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation;
                
                // Camera position update (Third-person view target)
                controls.target.copy(this.position.clone().add(new THREE.Vector3(0, 1.2, 0))); // Follow player's chest
                controls.update();

                // Rotate player mesh based on camera direction
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                // Non ruotiamo sul pitch, solo yaw
                cameraDirection.y = 0;
                
                // Ruotiamo il player per farlo guardare nella direzione della camera (per puntare le armi)
                this.rotation = Math.atan2(cameraDirection.x, cameraDirection.z);
            }
        }

        // --- BOT CLASS ---
        class Bot {
            constructor(position, id) {
                this.id = id;
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                this.rotation = 0;
                this.health = CONFIG.bot.health;
                this.maxHealth = CONFIG.bot.health;
                this.target = null;
                this.state = 'patrol';
                this.lastShootTime = 0;
                this.shootCooldown = 1500;
                this.patrolTarget = null;
                this.mesh = this.createMesh();
                this.mesh.userData = { isBot: true, entity: this, id: id };
                
                this.healthBar = this.createHealthBar();
            }

            createMesh() {
                const group = new THREE.Group();
                
                // Body (Capsula)
                const bodyGeometry = new THREE.CapsuleGeometry(0.3, 1.2, 4, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xE74C3C }); // Rosso
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.9;
                group.add(body);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshPhongMaterial({ color: 0xFFDBAC });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.6;
                group.add(head);
                
                group.position.copy(this.position);
                return group;
            }

            createHealthBar() {
                const group = new THREE.Group();
                
                // Background
                const bgGeometry = new THREE.PlaneGeometry(1, 0.1);
                const bgMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5 });
                const bg = new THREE.Mesh(bgGeometry, bgMaterial);
                group.add(bg);
                
                // Health fill
                const fillGeometry = new THREE.PlaneGeometry(1, 0.08);
                const fillMaterial = new THREE.MeshBasicMaterial({ color: 0x2ECC71 });
                const fill = new THREE.Mesh(fillGeometry, fillMaterial);
                fill.position.z = 0.01;
                group.add(fill);
                
                group.userData.fill = fill;
                group.position.y = 2.5;
                
                this.mesh.add(group);
                return group;
            }

            updateHealthBar() {
                const healthPercent = this.health / this.maxHealth;
                const fill = this.healthBar.userData.fill;
                fill.scale.x = healthPercent;
                fill.position.x = (healthPercent - 1) * 0.5;
                
                if (healthPercent > 0.6) {
                    fill.material.color.setHex(0x2ECC71);
                } else if (healthPercent > 0.3) {
                    fill.material.color.setHex(0xF39C12);
                } else {
                    fill.material.color.setHex(0xE74C3C);
                }
                
                // Billboard: fa ruotare la barra vita verso la telecamera
                this.healthBar.rotation.y = camera.rotation.y;
                this.healthBar.rotation.x = camera.rotation.x;
            }

            updateAI(player, deltaTime) {
                const distanceToPlayer = this.position.distanceTo(player.position);
                
                if (distanceToPlayer < CONFIG.bot.detectionRange) {
                    this.target = player;
                    
                    if (distanceToPlayer < CONFIG.bot.shootingRange) {
                        this.state = 'attack';
                    } else {
                        this.state = 'chase';
                    }
                } else {
                    this.state = 'patrol';
                    this.target = null;
                }
                
                let direction = new THREE.Vector3();
                let shootDirection = null;

                switch (this.state) {
                    case 'patrol':
                        direction = this.patrol(deltaTime);
                        break;
                    case 'chase':
                        direction = this.chase(deltaTime);
                        break;
                    case 'attack':
                        ({ direction, shootDirection } = this.attack(deltaTime));
                        break;
                }

                if (direction) {
                    // Update Position
                    this.position.x += direction.x * CONFIG.bot.speed * deltaTime;
                    this.position.z += direction.z * CONFIG.bot.speed * deltaTime;
                    this.rotation = Math.atan2(direction.x, direction.z);
                }

                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation;
                
                return shootDirection;
            }

            patrol(deltaTime) {
                if (!this.patrolTarget || this.position.distanceTo(this.patrolTarget) < 2) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 10 + Math.random() * 20;
                    this.patrolTarget = new THREE.Vector3(
                        this.position.x + Math.cos(angle) * distance,
                        0,
                        this.position.z + Math.sin(angle) * distance
                    );
                    
                    const halfSize = CONFIG.world.size / 2;
                    this.patrolTarget.x = Math.max(-halfSize + 5, Math.min(halfSize - 5, this.patrolTarget.x));
                    this.patrolTarget.z = Math.max(-halfSize + 5, Math.min(halfSize - 5, this.patrolTarget.z));
                }
                
                return new THREE.Vector3()
                    .subVectors(this.patrolTarget, this.position)
                    .normalize();
            }

            chase(deltaTime) {
                if (!this.target) return new THREE.Vector3();
                
                return new THREE.Vector3()
                    .subVectors(this.target.position, this.position)
                    .normalize();
            }

            attack(deltaTime) {
                if (!this.target) return { direction: new THREE.Vector3(), shootDirection: null };
                
                const direction = new THREE.Vector3()
                    .subVectors(this.target.position, this.position)
                    .normalize();
                
                const now = Date.now();
                if (now - this.lastShootTime > this.shootCooldown) {
                    this.lastShootTime = now;
                    // Bot spara con una piccola imprecisione
                    const aimDirection = direction.clone().add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    )).normalize();
                    return { direction: direction, shootDirection: aimDirection };
                }
                
                return { direction: direction, shootDirection: null };
            }

            takeDamage(amount, killer) {
                this.health = Math.max(0, this.health - amount);
                this.updateHealthBar();
                if (this.health <= 0) {
                    if (killer && killer.mesh.userData.isPlayer) {
                        gameState.kills++;
                        displayKillMessage('Giocatore', this.id.toString());
                    }
                    return true; // Eliminated
                }
                return false; // Still alive
            }
        }

        // --- CHEST CLASS ---
        class Chest {
            constructor(position) {
                this.position = position.clone();
                this.isOpen = false;
                this.loot = this.generateLoot();
                this.mesh = this.createMesh();
                this.mesh.userData = { isChest: true, entity: this };
            }

            createMesh() {
                const group = new THREE.Group();
                
                const baseGeometry = new THREE.BoxGeometry(1, 0.8, 0.8);
                const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.4;
                group.add(base);
                
                const lidGeometry = new THREE.BoxGeometry(1.02, 0.2, 0.82);
                const lidMaterial = new THREE.MeshPhongMaterial({ color: 0xA0522D });
                const lid = new THREE.Mesh(lidGeometry, lidMaterial);
                lid.position.y = 0.9;
                group.add(lid);
                
                group.userData.lid = lid;
                group.position.copy(this.position);
                
                return group;
            }

            generateLoot() {
                const weaponTypes = ['pistol', 'rifle', 'shotgun'];
                const randomType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                return { type: 'weapon', weaponType: randomType };
            }

            open() {
                if (!this.isOpen) {
                    this.isOpen = true;
                    audioManager.playChestOpen();
                    
                    // Animation: Open lid
                    const lid = this.mesh.userData.lid;
                    new TWEEN.Tween(lid.rotation)
                        .to({ x: -Math.PI / 2 }, 500)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();
                    new TWEEN.Tween(lid.position)
                        .to({ z: lid.position.z + 0.4 }, 500)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();
                    
                    // Spawn loot after opening
                    const lootPosition = this.position.clone().add(new THREE.Vector3(0, 0.5, 0));
                    const newWeapon = new Weapon(this.loot.weaponType, lootPosition);
                    scene.add(newWeapon.mesh);
                    interactables.push(newWeapon);
                    
                    // Make the chest non-interactable (already opened)
                    this.mesh.userData.isChest = false;

                    return this.loot;
                }
                return null;
            }
        }

        // ==================== GAME FUNCTIONS ====================

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 10, CONFIG.world.size * 0.7);

            // Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 50);

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
            directionalLight.position.set(50, 200, 50);
            scene.add(directionalLight);

            // Controls (Third Person Orbit)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enablePan = false;
            controls.minDistance = 5;
            controls.maxDistance = 15;
            controls.maxPolarAngle = Math.PI / 2.2; // Avoid going under the ground
            controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE; // Default: rotate
            controls.mouseButtons.RIGHT = THREE.MOUSE.DOLLY; // Default: zoom
            
            // World Generation
            createFloor();
            spawnBuildings();
            
            // Player and Bots
            player = new Player(new THREE.Vector3(0, 0, 0));
            scene.add(player.mesh);
            spawnBots(CONFIG.bot.count);
            
            // Spawn initial items
            spawnInteractables();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            startButton.addEventListener('click', startGame);

            // Initial HUD update
            updateHUD();
            
            // TweenJS for smooth animations
            if (typeof TWEEN === 'undefined') {
                loadTweenJS();
            } else {
                 animate();
            }
        }
        
        function loadTweenJS() {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.min.js';
            script.onload = () => animate();
            document.head.appendChild(script);
        }

        function startGame() {
            gameState.isPlaying = true;
            startScreenEl.style.display = 'none';
            // Enable controls (must be done after click to activate audio context)
            controls.enabled = true;
            // Place camera correctly at start
            camera.position.set(player.position.x, player.position.y + 8, player.position.z + 12);
        }

        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(CONFIG.world.size, CONFIG.world.size, 10, 10);
            floorGeometry.rotateX(-Math.PI / 2);
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x38761d });
            floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.userData.isFloor = true;
            scene.add(floorMesh);
        }
        
        function spawnBuildings() {
            const buildingPositions = [
                new THREE.Vector3(50, 0, 50),
                new THREE.Vector3(-50, 0, 50),
                new THREE.Vector3(0, 0, -80)
            ];

            buildingPositions.forEach((pos, index) => {
                const building = new Building(pos, index % 2 === 0 ? 'house' : 'tower');
                scene.add(building.mesh);
            });
        }
        
        function spawnInteractables() {
            // Spawn 3 Weapons and 3 Chests
            for (let i = 0; i < 3; i++) {
                // Weapons
                const posW = new THREE.Vector3(
                    (Math.random() * CONFIG.world.size - CONFIG.world.size / 2) * 0.8,
                    0,
                    (Math.random() * CONFIG.world.size - CONFIG.world.size / 2) * 0.8
                );
                const weaponTypes = ['pistol', 'rifle', 'shotgun'];
                const newWeapon = new Weapon(weaponTypes[i], posW);
                scene.add(newWeapon.mesh);
                interactables.push(newWeapon);

                // Chests
                const posC = new THREE.Vector3(
                    (Math.random() * CONFIG.world.size - CONFIG.world.size / 2) * 0.8,
                    0,
                    (Math.random() * CONFIG.world.size - CONFIG.world.size / 2) * 0.8
                );
                const newChest = new Chest(posC);
                scene.add(newChest.mesh);
                interactables.push(newChest);
            }
        }

        function spawnBots(count) {
            for (let i = 0; i < count; i++) {
                const position = new THREE.Vector3(
                    (Math.random() * CONFIG.world.size - CONFIG.world.size / 2) * 0.8,
                    0,
                    (Math.random() * CONFIG.world.size - CONFIG.world.size / 2) * 0.8
                );
                const bot = new Bot(position, i + 1);
                scene.add(bot.mesh);
                bots.push(bot);
            }
        }

        function updateHUD() {
            // Health Bar
            const healthPercent = player.health / player.maxHealth;
            healthFill.style.width = `${healthPercent * 100}%`;
            healthFill.textContent = player.health;
            if (healthPercent < 0.3) {
                healthFill.style.background = 'linear-gradient(90deg, #E74C3C, #C0392B)';
            } else {
                healthFill.style.background = 'linear-gradient(90deg, #2ECC71, #27AE60)';
            }

            // Weapon Info
            const currentWeapon = player.getCurrentWeapon();
            if (currentWeapon) {
                weaponNameEl.textContent = currentWeapon.config.name;
                ammoCountEl.textContent = `${currentWeapon.ammo} / ${currentWeapon.config.maxAmmo}`;
            } else {
                weaponNameEl.textContent = 'Nessuna Arma';
                ammoCountEl.textContent = '0 / 0';
            }
        }
        
        function displayKillMessage(killer, victim) {
            const messageEl = document.createElement('div');
            messageEl.className = 'kill-message';
            messageEl.innerHTML = `<span style="color:#3498DB;">${killer}</span> eliminato <span style="color:#E74C3C;">Bot ${victim}</span>`;
            
            killFeedEl.prepend(messageEl);
            
            setTimeout(() => {
                messageEl.remove();
            }, 5000);
        }
        
        function displayDamageIndicator(position, amount) {
            // Converte posizione 3D in coordinate 2D dello schermo
            const vector = position.clone();
            vector.project(camera);

            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

            const indicator = document.createElement('div');
            indicator.className = 'damage-indicator';
            indicator.textContent = Math.round(amount);
            indicator.style.left = `${x}px`;
            indicator.style.top = `${y}px`;

            document.body.appendChild(indicator);

            setTimeout(() => {
                indicator.remove();
            }, 1000);
        }

        // ==================== INPUT HANDLERS ====================

        function onKeyDown(event) {
            keys[event.key.toUpperCase()] = true;
            
            if (event.key.toUpperCase() === 'E') {
                interact();
            }
            
            // Switch Weapon Keys
            if (['1', '2', '3'].includes(event.key)) {
                const index = parseInt(event.key) - 1;
                player.switchWeapon(index);
            }
        }

        function onKeyUp(event) {
            keys[event.key.toUpperCase()] = false;
        }

        function onMouseDown(event) {
            if (!gameState.isPlaying) return;

            if (event.button === 0) { // Left Click (Shoot)
                const weapon = player.getCurrentWeapon();
                if (weapon && weapon.canFire()) {
                    
                    audioManager.playGunshot(weapon.type);

                    // Shooting direction is the center of the screen
                    const centerScreen = new THREE.Vector2(0, 0);
                    raycaster.setFromCamera(centerScreen, camera);
                    
                    const shootDirection = raycaster.ray.direction;
                    const origin = player.position.clone().add(new THREE.Vector3(0, 1.2, 0)); // From player's chest level
                    
                    // Fire weapon (handle shotgun pellets internally)
                    const fired = weapon.fire(origin, shootDirection, player);
                    
                    if (fired) {
                        // Project bullet on bots/interactables
                        const intersects = raycaster.intersectObjects(bots.map(b => b.mesh));
                        
                        if (intersects.length > 0) {
                            const hitMesh = intersects[0].object;
                            const bot = hitMesh.parent.userData.entity; // Get Bot object from mesh parent
                            
                            if (bot) {
                                audioManager.playHitSound();
                                displayDamageIndicator(bot.position, weapon.config.damage);
                                const eliminated = bot.takeDamage(weapon.config.damage, player);
                                
                                if (eliminated) {
                                    scene.remove(bot.mesh);
                                    bots = bots.filter(b => b !== bot);
                                }
                            }
                        }
                    }

                    updateHUD();
                }
            }
        }
        
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function interact() {
            const playerPos = player.position.clone().add(new THREE.Vector3(0, 1, 0)); // Chest height
            
            for (const item of interactables) {
                if (item.position.distanceTo(playerPos) < 5) {
                    if (item.mesh.userData.isWeapon) {
                        // Pickup Weapon
                        player.pickupWeapon(item);
                        break;
                    } else if (item.mesh.userData.isChest && !item.isOpen) {
                        // Open Chest
                        item.open();
                        break;
                    }
                }
            }
        }
        
        function checkInteractionPrompt() {
            const playerPos = player.position.clone().add(new THREE.Vector3(0, 1, 0));
            let promptText = '';
            
            for (const item of interactables) {
                if (item.position.distanceTo(playerPos) < 5) {
                    if (item.mesh.userData.isWeapon) {
                        promptText = `Premi E per raccogliere ${item.config.name}`;
                        break;
                    } else if (item.mesh.userData.isChest && !item.isOpen) {
                        promptText = `Premi E per aprire la Cassa`;
                        break;
                    }
                }
            }
            
            if (promptText) {
                interactionPromptEl.textContent = promptText;
                interactionPromptEl.style.display = 'block';
            } else {
                interactionPromptEl.style.display = 'none';
            }
        }

        // ==================== UPDATE LOOP ====================

        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            if (gameState.isPlaying) {
                TWEEN.update(); // Update TweenJS animations (for chest)

                // 1. Player Movement & Update
                updatePlayerMovement(deltaTime);
                player.update(deltaTime);
                checkInteractionPrompt();

                // 2. Bot AI & Combat
                updateBots(deltaTime);
                
                // 3. Bullet Physics & Collision
                updateBullets(deltaTime);
                
                // 4. Update Interactables (Floating animation)
                updateInteractables(deltaTime);
            }

            renderer.render(scene, camera);
        }
        
        function updatePlayerMovement(deltaTime) {
            const currentSpeed = (keys['SHIFT'] && !player.isJumping) ? CONFIG.player.speed * CONFIG.player.sprintMultiplier : CONFIG.player.speed;
            
            // Calculate movement direction relative to camera
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0; // Ignore camera pitch
            direction.normalize();

            const right = new THREE.Vector3().crossVectors(camera.up, direction).normalize();
            
            let moveX = 0;
            let moveZ = 0;

            if (keys['W']) moveZ -= 1; // Forward
            if (keys['S']) moveZ += 1; // Backward
            if (keys['A']) moveX -= 1; // Left
            if (keys['D']) moveX += 1; // Right

            const moveVector = new THREE.Vector3(moveX, 0, moveZ).normalize().multiplyScalar(currentSpeed);
            
            // Convert to world space movement
            const forwardMove = direction.clone().multiplyScalar(moveVector.z);
            const sideMove = right.clone().multiplyScalar(moveVector.x);

            // Apply movement (set velocity for smooth movement)
            player.velocity.x = forwardMove.x + sideMove.x;
            player.velocity.z = forwardMove.z + sideMove.z;
            
            // Jump
            if (keys[' '] && !player.isJumping) {
                player.velocity.y = CONFIG.player.jumpForce;
                player.isJumping = true;
            }
        }
        
        function updateBots(deltaTime) {
            bots = bots.filter(bot => {
                if (bot.health <= 0) {
                    scene.remove(bot.mesh);
                    return false;
                }
                
                const shootDirection = bot.updateAI(player, deltaTime);
                
                if (shootDirection) {
                    // Bot fires
                    const origin = bot.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                    // Bot always shoots with "Pistol" rules for simplicity
                    const config = CONFIG.weapons.pistol;
                    
                    audioManager.playGunshot('pistol');

                    bullets.push(new Bullet(
                        origin, 
                        shootDirection, 
                        config.damage, 
                        config.bulletSpeed, 
                        bot, 
                        'pistol'
                    ));
                }

                return true;
            });
        }
        
        function updateBullets(deltaTime) {
            bullets = bullets.filter(bullet => {
                if (!bullet.isActive()) {
                    scene.remove(bullet.mesh);
                    return false;
                }
                
                const stillActive = bullet.update(deltaTime);
                
                if (!stillActive) return false;
                
                // Collision check (Player)
                if (bullet.owner.mesh !== player.mesh && bullet.position.distanceTo(player.position.clone().add(new THREE.Vector3(0, 0.9, 0))) < 1) {
                    player.takeDamage(bullet.damage);
                    scene.remove(bullet.mesh);
                    return false;
                }
                
                // Collision check (Bots)
                let hitBot = null;
                for (const bot of bots) {
                    if (bullet.owner.mesh !== bot.mesh && bullet.position.distanceTo(bot.position.clone().add(new THREE.Vector3(0, 0.9, 0))) < 1) {
                        hitBot = bot;
                        break;
                    }
                }
                
                if (hitBot) {
                    hitBot.takeDamage(bullet.damage, bullet.owner);
                    scene.remove(bullet.mesh);
                    return false;
                }
                
                // Collision with floor (simple bounce/stop)
                if (bullet.position.y <= 0.1) {
                    scene.remove(bullet.mesh);
                    return false;
                }

                scene.add(bullet.mesh); // Ensure mesh is added if it's the first frame

                return true;
            });
        }
        
        function updateInteractables(deltaTime) {
            interactables.forEach(item => {
                if (item.mesh.userData.isWeapon) {
                    // Floating animation for weapons
                    item.mesh.rotation.y += 1 * deltaTime;
                    item.mesh.position.y = 0.5 + Math.sin(clock.elapsedTime * 2 + item.mesh.userData.floatOffset) * 0.1;
                }
            });
        }
        
        // ==================== BUILDING CLASS (COMPLETATO) ====================
        class Building {
            constructor(position, type = 'house') {
                this.position = position.clone();
                this.type = type;
                this.mesh = this.createMesh();
                this.mesh.userData = { isBuilding: true };
            }

            createMesh() {
                const group = new THREE.Group();
                
                if (this.type === 'house') {
                    const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xD2691E }); // Cioccolato
                    
                    // Walls
                    const walls = [
                        { dim: [8, 4, 0.2], pos: [0, 2, -4] },
                        { dim: [8, 4, 0.2], pos: [0, 2, 4] },
                        { dim: [0.2, 4, 8], pos: [-4, 2, 0] },
                        { dim: [0.2, 4, 8], pos: [4, 2, 0] }
                    ];

                    walls.forEach(w => {
                        const wall = new THREE.Mesh(new THREE.BoxGeometry(...w.dim), wallMaterial);
                        wall.position.set(...w.pos);
                        group.add(wall);
                    });
                    
                    // Roof
                    const roofGeometry = new THREE.CylinderGeometry(0, 5, 2, 4);
                    const roofMaterial = new THREE.MeshPhongMaterial({ color: 0xA52A2A }); // Marrone scuro
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.rotation.y = Math.PI / 4;
                    roof.position.y = 5;
                    group.add(roof);

                } else if (this.type === 'tower') {
                    const towerMaterial = new THREE.MeshPhongMaterial({ color: 0x708090 }); // Grigio ardesia
                    
                    // Base
                    const base = new THREE.Mesh(new THREE.BoxGeometry(6, 10, 6), towerMaterial);
                    base.position.y = 5;
                    group.add(base);
                    
                    // Top Platform
                    const platform = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 8), towerMaterial);
                    platform.position.y = 10;
                    group.add(platform);
                }
                
                group.position.copy(this.position);
                return group;
            }
        }
        
        // --- Esegui l'inizializzazione ---
        init();
    </script>
</body>
</html>
